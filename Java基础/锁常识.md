## CAS算法
V：要读写的内存值
A：进行比较的值
B：要写入的新值

V == A ？V = B | DO NOTHING
****
### 问题
1. ABA问题： A —> B -> A 
	值已经被修改过，但被当做没有修改
	解决方法：加版本号
2. 循环时间过长导致开销过大
	`私以为这是自旋锁的问题，而非CAS算法，CAS算法仅仅描述了[比较->交换]这一过程`
1. 只能保证单个变量原子性（1.5开始提供AtomicReference保证引用对象间原子性）
## 自旋锁与适应性自旋锁
实现原理为CAS
自旋锁并不能替代阻塞
自旋等待时间过长 则应该挂起线程 等待次数默认是10次，可以使用-XX:PreBlockSpin来更改

适应性自旋锁的旋转时间不再固定 由上次同锁的自选次数与拥有者状态决定 若在同一对象上刚刚获得过锁，且持有锁的线程正在运行，则此次也很可能成功，进而允许自选更长的时间 

## 无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁
锁的四种状态，专门针对synchronized

| Java对象头 | 
| :--: |
| MarkWord（标记字段） |
| KlassPoint （类型指针）|

### Monitor
线程私有，每个线程有一个可用Monitor列表，和一个全局可用列表
每个被锁住的对象都与一个Monitor关联，同时有一个Owner字段存放拥有锁的线程唯一标识

synchronized通过Monitor实现同步，Monitor依赖于底层的Mutex Lock（互斥锁）实现

| 锁状态 | 存储内容 | 存储内容 |
| :----:| :----: | :----: |
| 无锁 | 对象的hashCode、对象分代年龄、是否是偏向锁（0） | 01 |
| 偏向锁 | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01 |
| 轻量级锁 | 指向栈中锁记录的指针 | 00 |
| 重量级锁 | 指向互斥量（重量级锁）的指针 | 10 |

### 无锁
CAS实现，所有线程都能访问并修改资源，只有一个能修改成功
### 偏向锁
一段同步代码一直被同一个线程访问，线程会自动获取锁，降低得锁代价
偏向锁不会主动释放，只有在有其他线程尝试竞争偏向锁时才会释放
撤销偏向锁需要等待**全局安全点**（在这个时间点上没有字节码正在执行），其会先暂停拥有偏向锁的线程，判断对象现在是否被锁定 撤销后对象会变为***无锁***或***轻量级锁***状态
### 轻量级锁
锁是偏向锁时 被其他线程访问 则会升级为轻量级锁 其他线程进入**自旋**
轻量级锁的等待线程自旋超过一定次数或又有第三个线程来访，轻量级锁升级为重量级锁
### 重量级锁
等待锁的线程都会进入阻塞状态

## 公平锁、非公平锁
### 公平锁
按照**申请锁**的顺序获取，线程直接进入队列排队，除第一个线程外所有线程都会阻塞
### 非公平锁
多个线程加锁时先尝试获取锁，取不到再去队尾等待
若尝试获取时锁刚好可用，则可以直接获取到锁
优点：减少唤醒线程的开销
缺点：可能有线程饿死或等待很久才能获取锁
## 可重入锁
在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞
ReentrantLock和synchronized都是可重入锁
可以避免死锁（A.a() 调用 A.b() a获取锁LA后调用b 需要获取对象A的锁 但此时锁正在被自己持有 无法释放 形成死锁）
