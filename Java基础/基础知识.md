## 泛型
Java的泛型是**伪泛型**，在运行期间会被擦除
常用的通配符T(type),K(key),V(value),E(element,E[] array for(E e:array))
## == 与 equals
Java本质上是值传递，== 比较的是值，而对象的值是对象的地址
## hashCode()
返回一个int整数，定义在Object类中，本身是native的
（**规范上来说**）重写equals()时必须重写hashCode()，否则调用原生的hashCode方法两对象永远是不等的（堆上地址）
## 装箱与拆箱
Byte | Short | Integer | Long
[   -128   ,   127   ]
Character
[ 0 , 127 ]
Boolean
[TRUE，FALSE]
Float | Double
[无缓存]
## String类型
String类型在底层维护了一个private final char[]数组（jdk9后使用了byte[]数组）
StringBuffer与StringBuilder继承AbstractStringBuilder **没有**使用final修饰
String类型相当于线程常量，安全
StringBuffer的方法使用了同步锁，安全
StringBuilder不安全
**<font color=orange size=2>另：私以为对于String类来说线程安全并不在考虑范围内，因其维护的内部数组为常量，因而调用的方法皆为一致性方法 对于String线程安全性的讨论实际上是落在了其使用场景上下文的线程安全性上</font>**
## Object类型
toString()
toString()
hashCode()
notify()  /  notifyAll()
clone()
getClass()
equals()
wait()  --> 同步块内    Thread.sleep()  --> 所有位置
finalize()

## 异常
 - Throwable
	- Exception
		- CheckedException
			- IOException
			- FileNotFoundException
		- UncheckedException
			- NullPointerException
			- IndexOutOfBoundException
		- 
	- Error
		- StackOverflowError
		- OutOfMemoryError
## JDBC
Class.forName 装载Driver
jdbc标准中，Driver需要在DriverFactory中注册，
MySQL的实现是在static代码块中，将Driver初始化
因此使用ClassLoader.loadClass()进行注册将会失败，因为不进行对象初始化

## 深拷贝VS浅拷贝

```Java
//引用拷贝
Object one = new Object();
Object two = one;

//浅拷贝
Object one = new Object();
Object two = one.clone;

//深拷贝
Object one = new Object();
Object two = one.clone();

clone(){
	tareget.setParam1(target.getParam1().clone())
	tareget.setParam2(target.getParam2().clone())
}

```

## 反射
```Java 
Class a = TargetClass.class;

Class b = Class.forName("cn.abc.TargetClass")

TargetClass tc = new TargetClass;
Class c = tc.getClass();

Class d = ClassLoader.loadClass("cn.abc.TargetClass");
此种方式不会进行初始化
	
```